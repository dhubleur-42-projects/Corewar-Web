name: Release workflow

on:
    workflow_dispatch:

concurrency:
    group: ${{ github.workflow }}

jobs:
    lint:
        name: Lint
        uses: ./.github/workflows/lint.yaml

    variables:
        name: Store variables

        runs-on: ubuntu-24.04
        outputs:
            next_version: ${{ steps.next_version.outputs.next_version }}

        steps:
            - name: Checkout repo
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0 # Fetch all history for tags

            - name: Get latest release tag
              id: last_release
              run: |
                  TAG=$(git tag --sort=-creatordate | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -n1)
                  if [ -z "$TAG" ]; then
                    TAG="v0.0.0"
                  fi
                  echo "Found latest tag: $TAG"
                  echo "last_tag=$TAG" >> $GITHUB_OUTPUT

            - name: List commits since last release
              id: commits
              run: |
                  COMMITS=$(git log $LAST_TAG..HEAD --pretty=format:"%s" --no-merges)
                  echo "commits<<EOF" >> $GITHUB_OUTPUT
                  echo "$COMMITS" >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT
                  echo "Commits since $LAST_TAG:"
                  echo "$COMMITS"
              env:
                  LAST_TAG: ${{ steps.last_release.outputs.last_tag }}

            - name: Calculate next version
              id: next_version
              run: |
                  HAS_MAJOR=0
                  HAS_MINOR=0
                  HAS_PATCH=0
                  while read -r line; do
                    if [[ "$line" == *"BREAKING CHANGE"* ]] || [[ "$line" == *"!:"* ]]; then
                      HAS_MAJOR=1
                    elif [[ "$line" == feat* ]] || [[ "$line" == chore* ]] || [[ "$line" == perf* ]]; then
                      HAS_MINOR=1
                    else
                      HAS_PATCH=1
                    fi
                  done <<< "${{ steps.commits.outputs.commits }}"
                  IFS='.' read -r MAJOR MINOR PATCH <<< "${LAST_TAG#v}"
                  if [ $HAS_MAJOR -eq 1 ]; then
                    echo "Bumping major version"
                    MAJOR=$((MAJOR + 1))
                    MINOR=0
                    PATCH=0
                  elif [ $HAS_MINOR -eq 1 ]; then
                    echo "Bumping minor version"
                    MINOR=$((MINOR + 1))
                    PATCH=0
                  elif [ $HAS_PATCH -eq 1 ]; then
                    echo "Bumping patch version"
                    PATCH=$((PATCH + 1))
                  else
                    echo "No version bump needed"
                    exit 1
                  fi
                  NEXT_VERSION="$MAJOR.$MINOR.$PATCH"
                  echo "Next version: $NEXT_VERSION"
                  echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
              env:
                  LAST_TAG: ${{ steps.last_release.outputs.last_tag }}

    prepare-tags:
        name: Prepare tags
        needs: variables
        runs-on: ubuntu-24.04
        outputs:
            tags: ${{ steps.set-tags.outputs.tags }}
        steps:
            - name: Compute tags
              id: set-tags
              run: |
                  VERSION=${{ needs.variables.outputs.next_version }}

                  TAG_LIST="release-latest release-${VERSION}"

                  echo "Tags: $TAG_LIST"
                  echo "tags=$TAG_LIST" >> $GITHUB_OUTPUT

    build:
        name: Build apps
        needs:
            - prepare-tags
            - lint

        uses: ./.github/workflows/build-images.yaml
        with:
            buildArgs: |
                ENVIRONMENT=prod
            tags: ${{ needs.prepare-tags.outputs.tags }}
        secrets:
            DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
            DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}

    deploy:
        name: Deploy to production
        needs:
            - variables
            - build
        runs-on: ubuntu-24.04
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Set up kubeconfig
              run: |
                  mkdir -p ~/.kube
                  echo ${{ secrets.KUBE_CONFIG_DATA }} | base64 -d > ~/.kube/config

            - name: Deploy
              run: |
                  ./infra/deploy_prod.sh ${{ secrets.API_CLIENT_ID }} ${{ secrets.API_CLIENT_SECRET }} ${{ steps.next_version.outputs.next_version }}

            - name: Send Discord notification
              run: |
                  curl -H "Content-Type: application/json" \
                      -d "{\"content\": \"ðŸš€ **PROD** Deployment Info\n\nVersion \`${{ steps.next_version.outputs.next_version }}\` has been deployed to the **production environment**.\n\n- Frontend: \`https://corewar.ozyria.fr\`\n- Backend: \`https://corewar-api.ozyria.fr\`\n- Exec API: \`https://corewar-exec.ozyria.fr\`\"}" \
                      ${{ secrets.DISCORD_WEBHOOK_URL }}

    release:
        name: Create release
        needs:
            - deploy
            - variables
        runs-on: ubuntu-24.04
        steps:
            - name: Create GitHub release
              uses: actions/create-release@v1
              with:
                  tag_name: v${{ needs.variables.outputs.next_version }}
                  release_name: Release v${{ needs.variables.outputs.next_version }}
                  draft: false
                  prerelease: false
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    clean-old-images:
        name: Clean old release images
        needs: build
        uses: ./.github/workflows/clean-old-images.yaml
        with:
            tagPrefix: release-
            keepCount: 10
        secrets:
            DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
            DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
